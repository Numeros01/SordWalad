import copy, multiprocessing, random

from Bowl import Bowl
from Ingredients import*


SKIP_CHANCE = 0.7
MIN_CONTINUE_CHANCE = 0.3
MAX_CONTINUE_CHANCE = 0.7


def do_continue(current_depth, max_depth):
    r = (MAX_CONTINUE_CHANCE - MIN_CONTINUE_CHANCE) / max_depth
    chance = MIN_CONTINUE_CHANCE + (r * current_depth)
    if random.random() < chance:
        return True
    else:
        return False

def call_next(Calls):
    print(len(Calls))
    inx = random.randint(0, len(Calls) - 1)
    call = Calls[inx]
    Calls.pop(inx)
    call[0](*call[1]) # unpack args with *

def makeSalad(OutputSalads, ingredients):
    max_depth = ingredients.letterNumber - 1
    insertWord([], OutputSalads, 0, max_depth, Bowl(ingredients), 0)



def addSalad(OutputSalads, bowl):
    process_index = int(multiprocessing.current_process().name)

    OutputSalads.put(copy.deepcopy(bowl))
                        
    # if Salads[process_index].number >= MAX_SALAD_NUM:

        # removeSimilar(Salads[process_index])
        # sortSS(SaladsToAdd)

        # GenerationProcesses[process_index].terminate()
        # GenerationProcesses[process_index][1] = False;


def insertWord(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex):

    current_word = bowl.ingredients.words[wordIndex]

    bowl.clearLayers()

    if wordIndex == 0: # if is first word

        if do_continue(current_depth, max_depth):
            insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 0, 0, NOTHING, True)
            insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 0, 1, NOTHING, True)
            insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 1, 1, NOTHING, True)
        else:
            Calls.append((insertNextLetter, (Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 0, 0, NOTHING, True)))
            Calls.append((insertNextLetter, (Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 0, 1, NOTHING, True)))
            Calls.append((insertNextLetter, (Calls, OutputSalads, current_depth, max_depth, bowl, 0, 0, 1, 1, NOTHING, True)))
            call_next(Calls)
            call_next(Calls)
            call_next(Calls)

    else:

        letter_occured = False # if letter is present in grid, it can be reused
        n = 0

        for l in range(current_word.len):


            for row in bowl.grid:
                for sq in row:

                    if sq.letter == current_word.letters[l]: # if letters match

                        letter_occured = True
                        if do_continue(current_depth, max_depth):
                            insertPreviousLetter(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, l, sq.x, sq.y, sq, l, NOTHING)
                        else:
                            n+=1
                            Calls.append((insertPreviousLetter, (Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, l, sq.x, sq.y, sq, l, NOTHING)))

        for _ in range(n):
            call_next(Calls)

        if letter_occured == False or random.random() > SKIP_CHANCE: # can't anchor the word nowhere
            for row in bowl.grid:
                for sq in row:
                    insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, 0, sq.x, sq.y, NOTHING, True)





def insertPreviousLetter(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, letterIndex, i, j, end_sq, end_inx, code = NOTHING):

    currentLetter = bowl.ingredients.words[wordIndex].letters[letterIndex]

    if bowl.ingredients.get_letterNumber(currentLetter).req / bowl.ingredients.get_letterNumber(currentLetter).num > bowl.grid[i][j].con_num:
        # if letter requires more free spaces than current square has avaliable
        return

    elif bowl.grid[i][j].letter == EMPTY or (bowl.grid[i][j].letter == currentLetter and bowl.grid[i][j].layer == 0):
        # if this square is empty or contains same letter from different word
        bowl = copy.deepcopy(bowl)

        bowl.grid[i][j].letter = currentLetter
        bowl.grid[i][j].layer = 1 # layer 1 means square was used in making of this word

        if code != NOTHING:

            bowl.ingredients.words[wordIndex].code[letterIndex] = (code + 4) % 8 # invert code cos' going backwards
            income = calculateIncome(code)
            bowl.ingredients.words[wordIndex].difficulty += income
            bowl.difficulty += income

        if letterIndex == 0: # if is first letter

            bowl.grid[end_sq.x][end_sq.y].layer = 0
            if do_continue(current_depth, max_depth):
                insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, end_inx, end_sq.x, end_sq.y, NOTHING, False)
            else:
                Calls.append((insertNextLetter, (Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, end_inx, end_sq.x, end_sq.y, NOTHING, False)))
                call_next(Calls)

        else:

            same_letter_found = False
            n = 0

            for k in bowl.grid[i][j].cons:
                if bowl.grid[k.x][k.y].layer == 0 and bowl.grid[k.x][k.y].letter == bowl.ingredients.words[wordIndex].letters[letterIndex - 1]: # grid cell with same letter as previous in word
                    same_letter_found = True
                    if do_continue(current_depth, max_depth):
                        insertPreviousLetter(Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex - 1, k.x, k.y, end_sq, end_inx, k.code)
                    else:
                        Calls.append((insertPreviousLetter, (Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex - 1, k.x, k.y, end_sq, end_inx, k.code)))
                        n+=1

            for _ in range(n):
                call_next(Calls)
                    

            if same_letter_found == False or random.random() > SKIP_CHANCE:
                for k in bowl.grid[i][j].cons:
                    insertPreviousLetter(Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex - 1, k.x, k.y, end_sq, end_inx, k.code)

                

def insertNextLetter(Calls, OutputSalads, current_depth, max_depth, bowl, wordIndex, letterIndex, i, j, code, insert_now = True):

    currentLetter = bowl.ingredients.words[wordIndex].letters[letterIndex]

    if bowl.ingredients.get_letterNumber(currentLetter).req / bowl.ingredients.get_letterNumber(currentLetter).num > bowl.grid[i][j].con_num:
        # if letter requires more free spaces than current square has avaliable
        return

    elif bowl.grid[i][j].letter == EMPTY or ( bowl.grid[i][j].letter == currentLetter and bowl.grid[i][j].layer == 0):
        # if this square is empty or contains same letter from different word
        bowl = copy.deepcopy(bowl)

        if insert_now:

            bowl.grid[i][j].letter = currentLetter
            bowl.grid[i][j].layer = 1

            if code != NOTHING:

                bowl.ingredients.words[wordIndex].code[letterIndex - 1] = code;
                bowl.ingredients.words[wordIndex].difficulty += calculateIncome(code)
                bowl.difficulty += calculateIncome(code)

        if letterIndex + 1 == bowl.ingredients.words[wordIndex].len: # if is last letter

            if bowl.ingredients.words[wordIndex].difficulty >= bowl.ingredients.words[wordIndex].min_diff: # if word is difficult enough

                if wordIndex + 1 == bowl.ingredients.number: # if is last word

                    if bowl.checkMultiplePaths():
                        addSalad(OutputSalads, bowl)

                else: # insert next word
                    if do_continue(current_depth, max_depth):
                        insertWord(Calls, OutputSalads, current_depth, max_depth, copy.deepcopy(bowl), wordIndex + 1)
                    else:
                        Calls.append((insertWord, (Calls, OutputSalads, current_depth, max_depth, copy.deepcopy(bowl), wordIndex + 1)))
                        call_next(Calls)

        else: # insert next letter

            same_letter_found = False
            n = 0

            for k in bowl.grid[i][j].cons:
                # look for square with same letter as next in word
                if bowl.grid[k.x][k.y].layer == 0 and bowl.grid[k.x][k.y].letter == bowl.ingredients.words[wordIndex].letters[letterIndex + 1]:
                    same_letter_found = True
                    if do_continue(current_depth, max_depth):
                        insertNextLetter(Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex + 1, k.x, k.y, k.code, True)
                    else:
                        Calls.append((insertNextLetter, (Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex + 1, k.x, k.y, k.code, True)))
                        n+=1

            for _ in range(n):
                call_next(Calls)
                    

            if same_letter_found == False or random.random() > SKIP_CHANCE:
                for k in bowl.grid[i][j].cons:
                    insertNextLetter(Calls, OutputSalads, current_depth + 1, max_depth, bowl, wordIndex, letterIndex + 1, k.x, k.y, k.code, True)
